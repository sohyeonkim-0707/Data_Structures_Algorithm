// 선택 정렬 구현

function SelectionSort(arr) {
  // 1️⃣
  // 마지막 원소는 자동으로 정렬되기 때문에
  // 배열의 원소가 n개라면 n-1번 반복 ex) [1,4,2,3] 3번 반복
  for (let i = 0; i < arr.length - 1; i++) {
    let minValueIndex = i;
    // 최소값을 가진 인덱스를 저장할 변수 생성
    // 배열의 시작으로 0 이 아닌 i를 넣은 이유는 이 반복문을 한 번
    // 진행할 때마다 최소값이 하나 정렬되기 때문에 정렬된 영역은 반복에서 제외하기 위한 것.
    // ex) 지금처럼 1이 정렬되어 있다면 minValueIndex는 1이 되므로 1번 인덱스를 나타냄.

    // 2️⃣
    // 정렬되지 않은 영역의 첫 번째 원소부터 마지막 원소까지 순회하며
    // 가장 작은 값을 찾기 위한 for문을 만들어준다.
    // j의 값을 i 보다 1 크게 해준다.
    // i의 값은 이미 minValueIndex에 저장했기 때문.
    // 배열의 마지막 원소까지 반복!
    for (let j = i + 1; j < arr.length; j++) {
      // 3️⃣
      // 이제 정렬되지 않은 영역을 순회하다가 가장 작은 값을 발견하면 minValueIndex 인덱스에
      // 가장 작은 값의 위치를 저장해주자.
      // 현재 인덱스의 값이 지금까지 알려진 가장 작은 값보다 작다면
      if (arr[j] < arr[minValueIndex]) {
        // 현재 인덱스를 가장 작은 값의 인덱스로 저장한다.
        minValueIndex = j;
        // 이 for 문을 거치게 되면 minValueIndex에는
        // 정렬되지 않은 영역에서 가장 작은 값이 저장되게 된다.
        // 이 배열의 상황에선 minValueIndex는 2이다.
      }
    }
    // 4️⃣
    // 그럼 이 값을 정렬되지 않은 영역의 첫 번째 원소와 교체해주자.
    // 먼저 정렬되지 않은 영역의 첫 번째 원소를 임시 변수인 temp에 넣어준다.
    let temp = arr[i];
    // 첫 번째 원소를 가장 작은 값으로 덮어쓰고
    arr[i] = arr[minValueIndex];
    // 가장 작은 값이 있던 자리에 temp 값을 덯어써 줍니다.
    arr[minValueIndex] = temp;
    // 이렇게 되면 두 데이터가 교체가 된다.
  }
}

// ✅ 테스트 코드
let arr = [4, 2, 1, 3];

console.log("=== 정렬 전 ===");
console.log(arr); // 정렬 전

SelectionSort(arr); // 함수 호출해 배열 정렬

console.log("=== 정렬 후 ===");
console.log(arr); // 정렬 후

// 선택 정렬의 성능
// 버블 정렬과 마찬가지로 바깥쪽 for문이 실행될수록 안쪽 for문이 줄어드는 형태
// O(n2)
// 핵심계산을 하는 부분을 for문 두 개가 감싸고 있으니 n2으로 빠르게 확인할 수 있다.

// 선택 정렬의 장점과 단점
// 버블 정렬의 장점과 마찬가지로 구현하기 간단함
// 단점은 성능이 O(n2) 그렇게 좋지 않음.
