// 삽입정렬: 정렬되지 않은 영역에서 데이터를 하나씩 꺼내서
// 정렬된 영역 내  적절한 위치에 '삽입'해서 정렬하는 알고리즘

function InsertionSort(arr) {
  // 1️⃣ 정렬되지 않은 첫 번째 원소부터 시작해서
  // 마지막 원소까지 순회하기 위한 for 문을 넣어주자.
  // i가 1부터 시작하는 이유는 0번째 인덱스 즉 첫 번째 원소는 이미 정렬되어 있다고 가정
  for (let i = 1; i < arr.length; i++) {
    let insertingData = arr[i]; // i 인덱스에 해당하는 원소는 정렬되지 않은 영역의 첫 번째 데이터 따로 변수 저장
    // 2️⃣ 두번째 for 문
    // 정렬된 영역의 맨 뒤부터 첫 번째 원소까지 역순으로 순회하면서 정렬될 원소의 삽입 위치 찾기
    // 삽입 위치 기억하기 위해 j 변수 선언
    let j;
    // 정렬된 영역의 마지막 원소는 정렬되지 않은 영역의 첫 번째 원소의 한 칸 앞
    // 정렬되지 않은 영역의 첫 번째 원소는 i 이므로 j에는 i -1로 초기화를 해 정렬된 영역의 맨 뒤로 설정
    // 정렬된 영역의 마지막 인덱스부터 첫 번째 인덱스까지 역순으로 순회
    for (j = i - 1; j >= 0; j--) {
      // 현재 순회하는 인덱스의 원소가 삽입할 원소보다 크다면 오른쪽 인덱스에 덮어주기
      if (arr[j] > insertingData) {
        // 만약 해당 인덱스의 원소가 삽입할 원소보다 크다면 해당 인덱스의 원소를 오른쪽으로 덮어써주고
        arr[j + 1] = arr[j];
      } else {
        // 그렇지 않다면 삽입할 원소보다 작은 원소의 자리를 찾았으니 for문을 나와준다
        break;
        // 삽입할 원소보다 작은 원소의 인덱스는 j에 기록되어 있다.
      }
    }
    // 안쪽 for 문을 마치고 나오면 삽입할 배열의 위치가 정해진다.
    // [1,3,3,4,5,6]
    // 0번 인덱스(1) 다음, 즉 1번 인덱스에 2를 삽입
    // 그럼 j보다 1큰 위치에 insertingData를 '삽입'해준다.
    arr[j + 1] = insertingData;
  }
}

// test 코드
let arr = [4, 1, 5, 3, 6, 2]; // 정렬되지 않은 배열 선언

console.log("==== 정렬 전 ====");
console.log(arr);

InsertionSort(arr); // InsertionSort 함수 호출해 배열 정렬
console.log("==== 정렬 후 ===="); // 정렬 된 배열 출력
console.log(arr);

// ✅ 삽입 정렬의 성능 분석
// 버블 정렬, 선택 정렬과 같은 패턴의 for문
// O(n2) 성능

// ✅ 삽입 정렬의 장단점
// 이해가 쉽고 구현이 간단
// 성능이 좋지 못하다는 단점
